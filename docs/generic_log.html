<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Log Entry</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 min-h-screen p-4">
  <div class="max-w-2xl mx-auto bg-white p-6 rounded shadow">
    <h1 class="text-2xl font-bold mb-4 text-center" id="page-title">Log Entry</h1>

    <!-- Public Item Data (conditionally shown for Aura codes) -->
    <div id="public-item-data" class="mb-6 p-4 border border-gray-200 rounded-lg bg-gray-50 hidden">
      <h2 class="text-xl font-semibold mb-2 text-center">Item Details</h2>
      <p class="text-center text-gray-500" id="public-data-status">Loading item details...</p>
    </div>

    <!-- Main Log Content Area -->
    <div id="log-content-area">
      <!-- This area will be dynamically populated based on Aura/Terra -->
      <p class="text-center text-gray-500">Loading log configuration...</p>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getDatabase, ref, get, set, push, remove } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyAZoL7FPJ8wBqz_sX81Fo5eKXpsOVrLUZ0",
      authDomain: "tether-71e0c.firebaseapp.com",
      databaseURL: "https://tether-71e0c-default-rtdb.firebaseio.com",
      projectId: "tether-71e0c",
      storageBucket: "tether-71e0c.appspot.com",
      messagingSenderId: "277809008742",
      appId: "1:277809008742:web:2586a2b821d8da8f969da7"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    const pageTitle = document.getElementById("page-title");
    const publicItemDataDiv = document.getElementById("public-item-data");
    const publicDataStatus = document.getElementById("public-data-status");
    const logContentArea = document.getElementById("log-content-area");

    let currentQrId = null;
    let currentUserId = null;
    let currentLogScope = null;
    let currentTemplateId = null;

    let currentLogBasePath = null; 

    // Function to load and display public item data
    async function loadPublicItemData(qrId) {
      publicItemDataDiv.classList.remove("hidden");
      publicDataStatus.textContent = "Loading item details...";
      try {
        const publicRef = ref(db, `public_items_data/${qrId}`);
        const snap = await get(publicRef);
        const publicData = snap.val();

        if (publicData) {
          let content = `<h2 class="text-xl font-semibold mb-2 text-center">Item Details</h2>`;
          if (publicData.image_url) {
            content += `<img src="${publicData.image_url}" alt="Item Image" class="w-full h-48 object-cover rounded-md mb-4">`;
          }
          if (publicData.title) {
            content += `<h3 class="text-lg font-semibold mb-2">${publicData.title}</h3>`;
          }
          if (publicData.description) {
            content += `<p class="text-sm text-gray-700 mb-2">${publicData.description}</p>`;
          }
          if (publicData.tasting_notes) {
            content += `<p class="text-sm text-gray-700 mb-2"><strong>Tasting Notes:</strong> ${publicData.tasting_notes}</p>`;
          }
          if (publicData.website_link) {
            content += `<a href="${publicData.website_link}" target="_blank" class="text-blue-500 hover:underline text-sm">Visit Website</a>`;
          }
          publicItemDataDiv.innerHTML = content;
        } else {
          publicItemDataDiv.classList.add("hidden");
        }
      } catch (error) {
        console.error("Error loading public item data:", error);
        publicItemDataDiv.innerHTML = `<p class="text-center text-red-600">Error loading item details.</p>`;
      }
    }

    // Function to render log history
    async function renderLogs(logListElement, statusElement) {
      if (!currentLogBasePath) {
        logListElement.innerHTML = `<p class="text-center text-red-600">Log path not configured.</p>`;
        return;
      }

      logListElement.innerHTML = `<p class="text-center text-gray-500">Loading logs...</p>`;

      try {
        const logsRef = ref(db, currentLogBasePath);
        const snap = await get(logsRef);
        const logs = snap.val();
        logListElement.innerHTML = "";

        if (!logs) {
          logListElement.innerHTML = `<p class="text-center text-gray-500">No previous logs found for this item.</p>`;
          return;
        }

        const logEntries = Object.entries(logs).reverse();

        logEntries.forEach(([key, log]) => {
          const logEntryDiv = document.createElement("div");
          logEntryDiv.className = "p-4 bg-gray-50 rounded-lg shadow-sm flex justify-between items-center";

          let timestampText = 'N/A';
          if (log.timestamp && !isNaN(log.timestamp)) {
            timestampText = new Date(log.timestamp).toLocaleString();
          }

          const logDetails = Object.entries(log)
            .filter(([field, value]) => field !== 'timestamp')
            .map(([field, value]) => `<strong>${field}:</strong> ${value}`)
            .join("<br>");

          logEntryDiv.innerHTML = `
            <div>
              <p class="text-sm text-gray-400 mb-2">Logged at: ${timestampText}</p>
              <p class="text-gray-800">${logDetails}</p>
            </div>
            <button class="delete-entry-btn bg-red-400 hover:bg-red-500 text-white text-xs px-2 py-1 rounded-full" data-key="${key}">Delete</button>
          `;
          logListElement.appendChild(logEntryDiv);
        });

        document.querySelectorAll('.delete-entry-btn').forEach(button => {
          button.onclick = async (event) => {
            const entryKey = event.target.dataset.key;
            if (confirm("Are you sure you want to delete this specific log entry?")) {
              try {
                await remove(ref(db, `${currentLogBasePath}/${entryKey}`));
                statusElement.innerText = "Entry deleted!";
                setTimeout(() => statusElement.innerText = "", 3000);
                await renderLogs(logListElement, statusElement);
              } catch (error) {
                console.error("Error deleting entry:", error);
                statusElement.innerText = `Error deleting entry: ${error.message}`;
                statusElement.className = "mt-4 text-center text-sm text-red-600 font-bold";
              }
            }
          };
        });
    }

    // Function to set up event listeners for form and buttons
    function setupEventListeners(formElement, submitBtnElement, clearLogHistoryBtnElement, reconfigureQrBtnElement, statusElement, logListElement) {
      if (submitBtnElement) {
        submitBtnElement.onclick = async () => {
          const entries = {};
          Array.from(formElement.elements).forEach(input => {
            if (input.name) entries[input.name] = input.value;
          });
          entries.timestamp = Date.now();

          try {
            await push(ref(db, currentLogBasePath), entries);
            statusElement.innerText = "Entry saved!";
            setTimeout(() => statusElement.innerText = "", 3000);
            formElement.reset();
            await renderLogs(logListElement, statusElement);
          } catch (error) {
            console.error("Error saving log entry:", error);
            statusElement.innerText = `Error saving entry: ${error.message}`;
            statusElement.className = "mt-4 text-center text-sm text-red-600 font-bold";
          }
        };
      }

      if (clearLogHistoryBtnElement) {
        clearLogHistoryBtnElement.onclick = async () => {
          let confirmMessage = "";
          if (currentLogScope === 'personal') {
            confirmMessage = "Are you sure you want to clear YOUR personal log history for this template type? This will delete all YOUR entries for this specific log type (e.g., all your wine reviews).";
          } else { // 'shared'
            confirmMessage = "Are you sure you want to clear this SHARED log history for this item? This will delete ALL entries for this specific QR code for EVERYONE.";
          }

          if (!confirm(confirmMessage)) {
            console.log("Clear log history cancelled by user.");
            return;
          }

          try {
            await remove(ref(db, currentLogBasePath)); // Only delete entries
            statusElement.innerText = "Log history cleared successfully!";
            statusElement.className = "mt-4 text-center text-sm text-green-600 font-bold";
            setTimeout(() => statusElement.innerText = "", 3000);
            await renderLogs(logListElement, statusElement); // Re-render to show empty log
          } catch (error) {
            console.error("Error clearing log history:", error);
            statusElement.innerText = `Failed to clear log history: ${error.message}`;
            statusElement.className = "mt-4 text-center text-sm text-red-600 font-bold";
          }
        };
      }

      if (reconfigureQrBtnElement) {
        reconfigureQrBtnElement.onclick = async () => {
          let confirmMessage = "";
          if (currentLogScope === 'personal') {
            confirmMessage = "Are you sure you want to reconfigure this Aura QR code? This will delete its template assignment and allow you to choose a new template from the main page. Your existing personal log entries will remain, but the QR code will no longer link to this specific template.";
          } else { // 'shared'
            confirmMessage = "Are you sure you want to reconfigure this Terra QR code? This will delete its template assignment AND all shared log data, allowing you to choose a new template from the main page.";
          }

          if (!confirm(confirmMessage)) {
            console.log("Reconfiguration cancelled by user.");
            return;
          }

          try {
            await remove(ref(db, `qr_codes/${currentQrId}`));
            console.log(`QR code configuration for ${currentQrId} removed.`);

            // If Terra, also delete the associated shared log entries
            if (currentLogScope === 'shared' && currentLogBasePath) {
              await remove(ref(db, currentLogBasePath));
              console.log(`Shared log entries for ${currentQrId} at ${currentLogBasePath} removed.`);
            }

            statusElement.innerText = "QR code reconfigured! Redirecting...";
            statusElement.className = "mt-4 text-center text-sm text-green-600 font-bold";
            setTimeout(() => {
              window.location.href = `./index.html?id=${encodeURIComponent(currentQrId)}`;
            }, 1500);
          } catch (error) {
            console.error("Error reconfiguring QR code:", error);
            statusElement.innerText = `Failed to reconfigure QR code: ${error.message}`;
            statusElement.className = "mt-4 text-center text-sm text-red-600 font-bold";
          }
        };
      }
    }

    async function main() {
      const urlParams = new URLSearchParams(window.location.search);
      currentQrId = urlParams.get("id");
      currentUserId = urlParams.get("userId");

      console.log("generic_log.html loaded.");
      console.log("QR ID:", currentQrId);
      console.log("User ID from URL:", currentUserId);

      if (!currentQrId) {
        logContentArea.innerHTML = '<p class="text-red-600 font-bold text-center">Error: Missing QR ID in URL</p>';
        return;
      }

      try {
        const qrRef = ref(db, `qr_codes/${currentQrId}`);
        const snap = await get(qrRef);
        const qrData = snap.val();

        let template = null;
        let templateIdFromQr = null;

        // If qrData or its template is missing, redirect back to index.html
        if (!qrData || !qrData.template) {
          console.warn(`QR code ${currentQrId} not found or template missing. Redirecting to index.html for setup.`);
          logContentArea.innerHTML = `<p class="text-center text-gray-500">QR code not configured. Redirecting for setup...</p>`;
          setTimeout(() => {
            window.location.href = `./index.html?id=${encodeURIComponent(currentQrId)}`;
          }, 1000); // Give a short delay before redirecting
          return; // Stop further execution on this page
        }

        // If we reach here, qrData and qrData.template are guaranteed to exist
        currentLogScope = qrData.log_scope || 'shared';
        currentTemplateId = qrData.template;
        const templateRef = ref(db, `templates/${currentTemplateId}`);
        const templateSnap = await get(templateRef);
        template = templateSnap.val();

        if (!template || !template.fields) {
          console.warn(`Configured template '${currentTemplateId}' for QR ID ${currentQrId} is invalid or missing. Falling back to basic form.`);
          // If the template itself is bad, we still proceed, but with a default form
          template = { label: "Unknown Template", fields: [{ name: "Notes", type: "text" }] };
        }

        console.log("Final Determined Log Scope:", currentLogScope);
        console.log("Template ID from QR:", currentTemplateId);

        // Construct the form HTML based on the template (or default)
        let formHtml = '';
        if (template && template.fields) {
          Object.values(template.fields).forEach((field, idx) => {
            let inputHtml = '';
            if (field.type === "multichoice" && Array.isArray(field.options)) {
              let options = field.options.map(opt => `<option value="${opt}">${opt}</option>`).join('');
              inputHtml = `<select name="${field.name}" class="w-full p-2 border rounded">${options}</select>`;
            } else if (field.type === "date") {
              inputHtml = `<input type="date" name="${field.name}" class="w-full p-2 border rounded">`;
            } else if (field.type === "number") {
              inputHtml = `<input type="number" name="${field.name}" class="w-full p-2 border rounded">`;
            } else {
              inputHtml = `<input type="text" name="${field.name}" class="w-full p-2 border rounded">`;
            }
            formHtml += `
              <div class="field-block">
                <label class="block mb-1 font-medium">${field.name || `Field ${idx}`}:</label>
                ${inputHtml}
              </div>
            `;
          });
        } else {
          formHtml = `
            <div class="field-block">
              <label for="default-notes" class="block mb-1 font-medium">Notes:</label>
              <textarea id="default-notes" name="Notes" class="w-full p-2 border rounded" rows="4" placeholder="Add your notes here..."></textarea>
            </div>
          `;
        }

        // Construct the main content HTML
        let mainContentHtml = `
          <form id="dynamic-log-form" class="space-y-4">
            ${formHtml}
          </form>
          <button id="submit-btn" class="mt-4 w-full bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded">Submit</button>
          <button id="clear-log-history-btn" class="mt-2 w-full bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded">Clear Log History</button>
          <button id="reconfigure-qr-btn" class="mt-2 w-full bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded">Reconfigure QR Code</button>
          <p id="dynamic-status" class="mt-4 text-center text-sm text-gray-600"></p>
          <div id="log-history-section" class="mt-8 border-t pt-4">
            <h2 class="text-xl font-bold mb-4 text-center" id="log-history-title">Log History</h2>
            <div id="log-list" class="space-y-4"></div>
          </div>
        `;
        logContentArea.innerHTML = mainContentHtml;

        // Re-get references to the dynamically created elements
        const formElement = logContentArea.querySelector("#dynamic-log-form");
        const submitBtnElement = logContentArea.querySelector("#submit-btn");
        const clearLogHistoryBtnElement = logContentArea.querySelector("#clear-log-history-btn");
        const reconfigureQrBtnElement = logContentArea.querySelector("#reconfigure-qr-btn");
        const statusElement = logContentArea.querySelector("#dynamic-status");
        const logHistoryTitleElement = logContentArea.querySelector("#log-history-title");
        const logListElement = logContentArea.querySelector("#log-list");

        // Set page title and log history title based on scope and template
        const templateLabel = template ? (template.label || currentTemplateId) : "Unconfigured Log";
        if (currentLogScope === 'personal') {
          pageTitle.textContent = `Aura: ${templateLabel}`;
          logHistoryTitleElement.textContent = `My ${templateLabel} History`;
          currentLogBasePath = `users/${currentUserId}/logs/${currentTemplateId}/entries`; // Aura path
          publicItemDataDiv.classList.remove('hidden'); // Show public data for Aura
        } else {
          pageTitle.textContent = `Terra: ${templateLabel}`;
          logHistoryTitleElement.textContent = `Shared ${templateLabel} History`;
          publicItemDataDiv.classList.add('hidden'); // Hide public data for Terra
        }

        // Setup event listeners for the dynamically created elements
        setupEventListeners(formElement, submitBtnElement, clearLogHistoryBtnElement, reconfigureQrBtnElement, statusElement, logListElement);
        await renderLogs(logListElement, statusElement);
        if (currentLogScope === 'personal') {
          await loadPublicItemData(currentQrId);
        }

      } catch (err) {
        console.error("An error occurred during log page initialization:", err);
        logContentArea.innerHTML = `<p class="text-red-600 font-bold text-center">An unexpected error occurred: ${err.message}</p>`;
      }
    }

    main();
  </script>
</body>
</html>
